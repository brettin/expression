#------------------------------------------------------------------------------#
# Documentation Section                                                        #
#------------------------------------------------------------------------------#

=head1 NAME

geotoexch.pl - consumes & transforms GEO parser output to KBase expression exchange format.

=head1 SYNOPSIS

 geotoexch.pl [--? --m] --p --l --v --g --o
   --p <provider identifier: data loader's email address e.g. kumari@cshl.edu>
   --l <load space identifier: e.g. PlantExprAffyPipeline>
   --v <version number: positive integet starting from 1>
   --g <file containing list of GSEs>
   --o <directory path for writing output files to>

=head1 DESCRIPTION

This scripts consumes the meta-data and expression data generated by the GEO
parser and subsequently transforms the data into KBase expression exchange
format. The output files generated from this scripts are for direct consumption
by the KBase expression database uploader scripts.

=head1 OPTIONS

=over 4

=item B<--p or -p>

        Required parameter for the data provider's identifier. See the Appendix
        section (source-id structure - [provider ID]:[load ID].[version]|[data ID])
        of the expression exchange service for more details. Provider-id usually is
        the email address of the data loader.

=item B<--l or -l>

        Required parameter for the data load portion of the source-id - 
        [provider ID]:[load ID].[version]|[data ID]. For example,
        PlantExprAffyPipeline can be used as the load-id for plant expression data.

=item B<--v or -v>

        Required parameter corresponding to the version part of the load-id as
        defined in the source-id structure section of the Appendix of the 
        expression exchange service.

=item B<--g or -g>

        Required parameter to input list of GSE# for which the data needs to be 
        extracted from NCBI GEO. This must be a text file that has one GSE per line.

=item B<--o>

	Path to the directory where this script would write .tab files. If this
	parameter is not provided then by default the script would write .tab
	files into current working directory.

=item B<--help or -? or -h>

        Print quick help message on using geotoexch.pl and exit

=item B<--man or -m>

        Print complete documentation on using geotoexch.pl and exit

=back

=head1 AUTHOR

Dr. Sunita Kumari

=head1 DATE

Fri Aug 5 09:24:30 EST 2013

=head1 USAGE EXAMPLE

How to use geotoexch.pl
 perl geotoexch.pl --p=kumari@cshl.edu --l=PlantExprAffyPipeline --v=1 --g=gse_list.in --o=~/data
 perl geotoexch.pl --m # use this option only to read the documentation

=cut

#------------------------------------------------------------------------------#
# Import Section: Import perl modules on which this script depends             #
#------------------------------------------------------------------------------#
use Getopt::Long;
use Pod::Usage;
use warnings;
use DateTime;
use Data::Dumper;
use Bio::KBase::ExpressionServices::ExpressionServicesClient;

#------------------------------------------------------------------------------#
# Boiler plate code for extracting command-line options & displaying help/man  #
#------------------------------------------------------------------------------#

my $help;
my $man;
my %opts = ("help" => \$help, "man" => \$man);
Getopt::Long::Configure("bundling", "auto_abbrev");
GetOptions(\%opts, "help|?|h", "man|m", "p=s", "l=s", "v=i", "g=s", "o=s");
pod2usage(1) if $help;
pod2usage(-verbose => 2) if $man;

#------------------------------------------------------------------------------#
# Start: geotoexch.pl Main Logic                                               #
#------------------------------------------------------------------------------#

$Data::Dumper::Purity = 1;
my $client = Bio::KBase::ExpressionServices::ExpressionServicesClient->new("http://localhost:7075");

#restore hash from the input file
##my $infile = $ARGV[0];
##open FILE, $infile;
##undef $/;
##my $href = eval <FILE>;
##close FILE;

# find out if user provided output directory for writing out .tab files
my $odir = $opts{'o'};
if(!defined($odir)) {
	$odir = ".";
}

# open .tab files for writing
open(SER, ">$odir/series.tab");
open(SAM, ">$odir/sample.tab");
open(PER, ">$odir/person.tab");
open(PRO, ">$odir/protocol.tab");
open(PLA, ">$odir/platform.tab");

# write header line for each .tab file
print SER "source-id\texternalSourceId\tkbaseSubmissionDate\texternalSourceDate\tpublicationIds\tsamples\ttitle\tsummary\tdesign\n";
print SAM "source-id\tmolecule\ttype\texternalSourceId\tdataSource\tkbaseSubmissionDate\texternalSourceDate\toriginalLog2Median\tpersons\tstrain-id\tplatform-id\tprotocol-id\texperimentalUnit-id\tdefaultControlSample-id\taveragedFromSamples\ttitle\tdescription\n";
print PER "source-id\tContact-Email\tFirst-Name\tLast-Name\tInstitution\n";
print PRO "source-id\tPublication\tName\tDescription\n";
print PLA "source-id\tstrain-id\ttype\ttechnology\texternalSourceId\ttitle\n";

# Common Data Fields: source-id base string and today's date
my $providerId = $opts{'p'} || die pod2usage(1); #"kumari\@cshl.edu";
my $loadId = $opts{'l'} || die pod2usage(1);     #"PlantExprAffyPipeline";
my $ver = $opts{'v'} || die pod2usage(1);        #1;
my $sourceIdBase = "$providerId:$loadId.$ver|";
my $dt = DateTime->now;   # Store current date and time as datetime object
my $d  = $dt->ymd;        # Retrieve date as in 'yyyy-mm-dd' format

# get input list of GSEs
my $gsefile = $opts{'g'} || die pod2usage(1);
my @gses;
open(GSE, "<$gsefile");
while(<GSE>) {
	chomp;
	push(@gses, $_);
}
my $numgses = @gses;
my $cnt = 0;

# turn off STDOUT buffering i.e. flush immediately
$| = 1;

my %persons = ();
my %platforms = ();
open(ERR, ">$odir/gse_error_log");
open(WAR, ">$odir/gse_warning_log");

foreach my $gse (@gses) {
	++$cnt;
	print "\rProcessing $gse ($cnt of $numgses) ...";
	my %samples = ();   # holds GSM to sample source-id mappig
	my %protocols = (); # holds each protocol used within a GSE context
	my $href = $client->get_GEO_GSE($gse,1); #'GSE22671',1);
	my $protCount = 1;  # protocol counter for the GSE
	my @gseErrors = @{$href->{'gseErrors'}};
	my @gseWarnings = @{$href->{'gseWarnings'}};
	if(@gseErrors) {
		print ERR "$gse error:\n";
		foreach my $err (@gseErrors) {
			print ERR "$err\n";
		}
	}
	if(@gseWarnings) {
		print WAR "$gse warnings:\n";
		foreach my $warn (@gseWarnings) {
			print WAR "$warn\n";
		}
	}
	# write data to series.tab
	my $gseId = $href->{'gseID'};
	my $gseSubmissionDate =  $href->{'gseSubmissionDate'};
	my $gsePubMedID = $href->{'gsePubMedID'};
	if(!defined($gsePubMedID)) {
		$gsePubMedID = ".";
	}
	my $gsmref = $href->{'gseSamples'};
	my $gsm = "";
	foreach my $k (keys(%{$gsmref})) {
		$gsm .= "$sourceIdBase$k,";
	}
	$gsm =~ s/,$//;
	my $title = $href->{'gseTitle'};
	$title = substr($title,0,500);
	my $summary = $href->{'gseSummary'};
	$summary = substr($summary,0,500);
	my $design = $href->{'gseDesign'};
	$design = "Not available from source" if(!defined($design));
	$design = substr($design,0,500);
	my $seriesSrcId = "$sourceIdBase$gseId";
	print SER "$seriesSrcId\t$gseId\t$d\t$gseSubmissionDate\t$gsePubMedID\t$gsm\t$title\t$summary\t$design\n";
	
	# write data to sample.tab
	# NOTE: gsmPlatform{'gplID' => 'GPL198'}
	foreach my $g (keys(%{$href->{'gseSamples'}})) {
		my @gsmErrors = @{$gsmref->{$g}->{'errors'}};
		my @gsmWarnings = @{$gsmref->{$g}->{'warnings'}};
		if(@gsmErrors) {
			foreach my $error (@gsmErrors) {
				print ERR "$gse->$g: $error\n";
			}
		}
		if(@gsmWarnings) {
			foreach my $warning (@gsmWarnings) {
				print WAR "$gse->$g: $warning\n";
			}
		}
		my $gsmOrganism = $gsmref->{$g}->{'gsmSampleOrganism'};
		$gsmOrganism =~ s/\s+/_/;
		my $sampleSrcId = "$sourceIdBase$g";
		$samples{$g} = $sampleSrcId; # store GSM source-id
		my $molecule = $gsmref->{$g}->{'gsmMolecule'};
		if(!defined($molecule)) {
			$molecule = "UNKNOWN";
		}
		my $type = "microarray";                                       #$gsmref->{$g}->{''};
		my $dataSource = "GEO";                                        #$gsmref->{$g}->{''};
		my $externalSourceDate = $gsmref->{$g}->{'gsmSubmissionDate'};
		my $originalLog2Median = ".";                                  #$gsmref->{$g}->{''};
		my $person = "";
		my $pref = $gsmref->{$g}->{'contactPeople'};
		foreach my $email (keys(%{$pref})) {
			my $fn = $pref->{$email}->{'contactFirstName'};
			my $ln = $pref->{$email}->{'contactLastName'};
			$ln = "NotGiven" if(!defined($ln));
			my $inst = $pref->{$email}->{'contactInstitution'};
			# Take care of the redundancy (if any) due to letter-case
			$email = lc($email);
			$fn = lc($fn);
			$ln = lc($ln);
			$inst = lc($inst);
			my $personSrcId = "$email:$loadId.$ver|$fn$ln";
			$person = $person.$personSrcId.",";
			my $personkey = "$personSrcId\t$email\t$fn\t$ln\t$inst";
			$persons{$personkey} = 1;
		}
		$person =~ s/,$//; # remove last comma from the string
		my $strainId = $gsmref->{$g}->{'gsmTaxID'};
		my $platformRef = $gsmref->{$g}->{'gsmPlatform'};
		my $gpl = $platformRef->{'gplID'};
		my $platformSrcId = "$sourceIdBase$gpl";
		my $strainSrcId = "$providerId:$strainId.$ver|$gsmOrganism";
		if(!defined($platforms{$platformSrcId})) {
			my $gplTaxId = $platformRef->{'gplTaxID'};
			my $gplTechnology = $platformRef->{'gplTechnology'};
			my $gplTitle = $platformRef->{'gplTitle'};
			$platforms{$platformSrcId} = "$gplTaxId\t$type\t$gplTechnology\t$gpl\t$gplTitle";
		}
		my $gsmProtocolDesc = $gsmref->{$g}->{'gsmProtocol'};
		my $protocolSrcId = $protocols{$gsmProtocolDesc};
		if(!defined($protocols{$gsmProtocolDesc})) {
			$protocolSrcId = "$sourceIdBase$gseId-Protocol_$protCount";
			$protocols{$gsmProtocolDesc} = $protocolSrcId;
			++$protCount;
		}
		my $experimentalUnitId = ".";                                  #$gsmref->{$g}->{''};
		my $defaultControlSampleId = ".";                              #$gsmref->{$g}->{''};
		my $averagedFromSamples = ".";                                 #$gsmref->{$g}->{''};
		my $title = $gsmref->{$g}->{'gsmTitle'};
		my $description = $gsmref->{$g}->{'gsmDescription'};
		print SAM "$sampleSrcId\t$molecule\t$type\t$g\t$dataSource\t$d\t$externalSourceDate\t$originalLog2Median\t$person\t$strainSrcId\t$platformSrcId\t$protocolSrcId\t$experimentalUnitId\t$defaultControlSampleId\t$averagedFromSamples\t$title\t$description\n";
	}
	foreach my $kk (keys(%protocols)) {
		my $protocolSrcId = $protocols{$kk};
		print PRO "$protocolSrcId\t.\tno-name\t$kk\n"; # where $kk = Protocol Description;
	}
}

print "\nWriting out person.tab and platform.tab ...\n";

# write data to person.tab
foreach my $k (keys(%persons)) {
	print PER "$k\n";
}

# write data to platform.tab
foreach my $k (keys(%platforms)) {
	print PLA "$k\t".$platforms{$k}."\n";
}

# close all open files
close SER;
close SAM;
close PER;
close PRO;
close PLA;
close ERR;
close WAR;
