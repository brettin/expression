#------------------------------------------------------------------------------#
# Documentation Section                                                        #
#------------------------------------------------------------------------------#

=head1 NAME

geotoexch.pl - consumes & transforms GEO parser output to KBase expression exchange format.

=head1 SYNOPSIS

 geotoexch.pl [--? --m] --p --l --v --g --o
   --p <provider identifier: data loader's email address e.g. kumari@cshl.edu>
   --l <load space identifier: e.g. PlantExprAffyPipeline>
   --v <version number: positive integet starting from 1>
   --g <file containing list of GSEs>
   --o <directory path for writing output files to>

=head1 DESCRIPTION

This scripts consumes the meta-data and expression data generated by the GEO
parser and subsequently transforms the data into KBase expression exchange
format. The output files generated from this scripts are for direct consumption
by the KBase expression database uploader scripts.

=head1 OPTIONS

=over 4

=item B<--p or -p>

        Required parameter for the data provider's identifier. See the Appendix
        section (source-id structure - [provider ID]:[load ID].[version]|[data ID])
        of the expression exchange service for more details. Provider-id usually is
        the email address of the data loader.

=item B<--l or -l>

        Required parameter for the data load portion of the source-id - 
        [provider ID]:[load ID].[version]|[data ID]. For example,
        PlantExprAffyPipeline can be used as the load-id for plant expression data.

=item B<--v or -v>

        Required parameter corresponding to the version part of the load-id as
        defined in the source-id structure section of the Appendix of the 
        expression exchange service.

=item B<--g or -g>

        Required parameter to input list of GSE# for which the data needs to be 
        extracted from NCBI GEO. This must be a text file that has one GSE per line.

=item B<--o>

	Path to the directory where this script would write .tab files. If this
	parameter is not provided then by default the script would write .tab
	files into current working directory.

=item B<--help or -? or -h>

        Print quick help message on using geotoexch.pl and exit

=item B<--man or -m>

        Print complete documentation on using geotoexch.pl and exit

=back

=head1 AUTHOR

Dr. Sunita Kumari

=head1 DATE

Fri Aug 5 09:24:30 EST 2013

=head1 USAGE EXAMPLE

How to use geotoexch.pl
 perl geotoexch.pl --p=kumari@cshl.edu --l=PlantExprAffyPipeline --v=1 --g=gse_list.in --o=~/data
 perl geotoexch.pl --m # use this option only to read the documentation

=cut

#------------------------------------------------------------------------------#
# Import Section: Import perl modules on which this script depends             #
#------------------------------------------------------------------------------#
use Getopt::Long;
use Pod::Usage;
use warnings;
use DateTime;
use Data::Dumper;
use Bio::KBase::ExpressionServices::ExpressionServicesClient;
use DBI;
use Digest::MD5 qw(md5 md5_hex md5_base64);

#------------------------------------------------------------------------------#
# Boiler plate code for extracting command-line options & displaying help/man  #
#------------------------------------------------------------------------------#

my $help;
my $man;
my %opts = ("help" => \$help, "man" => \$man);
Getopt::Long::Configure("bundling", "auto_abbrev");
GetOptions(\%opts, "help|?|h", "man|m", "p=s", "l=s", "v=i", "g=s", "o=s");
pod2usage(1) if $help;
pod2usage(-verbose => 2) if $man;

#------------------------------------------------------------------------------#
# Start: geotoexch.pl Main Logic                                               #
#------------------------------------------------------------------------------#

$Data::Dumper::Purity = 1;
my $client = Bio::KBase::ExpressionServices::ExpressionServicesClient->new("http://localhost:7075");

#restore hash from the input file
##my $infile = $ARGV[0];
##open FILE, $infile;
##undef $/;
##my $href = eval <FILE>;
##close FILE;

# find out if user provided output directory for writing out .tab files
my $odir = $opts{'o'};
if(!defined($odir)) {
	$odir = ".";
}

# open .tab files for writing
open(SER, ">$odir/series.tab");
open(SAM, ">$odir/sample.tab");
open(PER, ">$odir/person.tab");
open(PRO, ">$odir/protocol.tab");
#open(PLA, ">$odir/platform.tab");
#open(STR, ">$odir/strain.tab");
open(PUB, ">$odir/publication.tab");
open(LOG, ">$odir/plexpr.log");
open(PAS, ">$odir/Good_GSE_GSM");

# write header line for each .tab file
print SER "source-id\texternalSourceId\tkbaseSubmissionDate\texternalSourceDate\tpublicationIds\tsamples\ttitle\tsummary\tdesign\n";
print SAM "source-id\ttitle\tdescription\tmolecule\ttype\texternalSourceId\tdataSource\tkbaseSubmissionDate\texternalSourceDate\toriginalLog2Median\tpersons\tstrain-id\tplatform-id\tprotocol-id\texperimentalUnit-id\tdefaultControlSample-id\taveragedFromSamples\n";
print PER "source-id\tContact-Email\tFirst-Name\tLast-Name\tInstitution\n";
print PRO "source-id\tPublication\tName\tDescription\n";
print PUB "source-id\tPubdate\tTitle\n";
#print PLA "source-id\tstrain-id\ttype\ttechnology\texternalSourceId\ttitle\n";
#print STR "source-id\tAggregateData\tName\tReference-strain\tParent-strain-id\tGenome-id\tKnockouts\tWildtype\tDescription\n";

# HARD CODED KB|IDs ... this code needs to be refactored after initial load (19-Sep-2013)
my $athStrId = "kb|str.18125";
my $ptrStrId = "kb|str.18126";
my $athPlaId = "kb|platform.1";
my $ptrPlaId = "kb|platform.2";

# Common Data Fields: source-id base string and today's date
my $providerId = $opts{'p'} || die pod2usage(1); #"kumari\@cshl.edu";
my $loadId = $opts{'l'} || die pod2usage(1);     #"PlantExprAffyPipeline";
my $ver = $opts{'v'} || die pod2usage(1);        #1;
my $sourceIdBase = "$providerId:$loadId.$ver|";
my $dt = DateTime->now;   # Store current date and time as datetime object
my $d  = $dt->ymd;        # Retrieve date as in 'yyyy-mm-dd' format
# get input list of GSEs
my $db1h = DBI->connect('DBI:mysql:expression;host=db1.chicago.kbase.us','expressionselect','',{ RaiseError => 1, ShowErrorStatement => 1});
my $strainIdQuery = "select s.id from Strain s inner join  GenomeParentOf g where s.refe.wildtype='Y' and g.from_link=?"; #Ath='kb|g.3899'; Ptr='kb|g.3907'
my $platformIdQuery = "";
my $genomeIdQuery = "select id as genomeid from kbase_sapling_v1.Genome where scientific_name=?";
my $sth = $db1h->prepare($genomeIdQuery);

my $gsefile = $opts{'g'} || die pod2usage(1);
my @gses;
open(GSE, "<$gsefile");
while(<GSE>) {
	chomp;
	push(@gses, $_);
}
my $numgses = @gses;
my $cnt = 0;

# turn off STDOUT buffering i.e. flush immediately
$| = 1;

#my $unk = 1;  # counter for creating unquite "unknown" as a data value
my %persons = ();
#my %platforms = ();
my %publication = ();
#my %strain = ();
open(ERR, ">$odir/plexpr_erro.log");
open(WAR, ">$odir/plexpr_warn.log");

foreach my $gse (@gses) {
	++$cnt;
	print "\rProcessing $gse ($cnt of $numgses) ...";
	my %samples = ();   # holds GSM to sample source-id mappig
	my %protocols = (); # holds each protocol used within a GSE context
	my $href = $client->get_GEO_GSE($gse,1); #'GSE22671',1);
	my $protCount = 1;  # protocol counter for the GSE
	my @gseErrors = @{$href->{'gseErrors'}};
	my @gseWarnings = @{$href->{'gseWarnings'}};
	if(@gseErrors) {
		print ERR "$gse error:\n";
		foreach my $err (@gseErrors) {
			print ERR "$err\n";
		}
		next; # don't parse rest of the series data
	}
	if(@gseWarnings) {
		print WAR "$gse warnings:\n";
		foreach my $warn (@gseWarnings) {
			print WAR "$warn\n";
		}
	}
	# write data to series.tab
	my $gseId = $href->{'gseID'};
	my $gseSubmissionDate =  $href->{'gseSubmissionDate'};
	my $gsePubMedID = $href->{'gsePubMedID'};
	if(!defined($gsePubMedID)) {
		$gsePubMedID = ".";
	} else {
		$gsePubMedID =~ s/\s+/_/g;
		$gsePubMedID = "pubmed|$gsePubMedID";
		$publication{$gsePubMedID} = $gseSubmissionDate;
	}
	my $gsmref = $href->{'gseSamples'};
	my $gsm = "";
	#foreach my $k (keys(%{$gsmref})) {
	#	$gsm .= "$sourceIdBase$k,";
	#}
	#$gsm =~ s/,$//;
	my $title = $href->{'gseTitle'};
	$title = substr($title,0,500);
	my $summary = $href->{'gseSummary'};
	$summary = substr($summary,0,500);
	my $design = $href->{'gseDesign'};
	$design = "Not available from source" if(!defined($design));
	$design = substr($design,0,500);
	my $seriesSrcId = "$sourceIdBase$gseId";
	
	# write data to sample.tab
	# NOTE: gsmPlatform{'gplID' => 'GPL198'}
	foreach my $g (keys(%{$href->{'gseSamples'}})) {
		my @gsmErrors = @{$gsmref->{$g}->{'errors'}};
		my @gsmWarnings = @{$gsmref->{$g}->{'warnings'}};
		if(@gsmErrors) {
			foreach my $error (@gsmErrors) {
				print ERR "$gse->$g: $error\n";
			}
			next; # don't parse rest of the GSM data
		}
		my $unkemail = 0;  # initially assume email is given
		if(@gsmWarnings) {
			foreach my $warning (@gsmWarnings) {
				print WAR "$gse->$g: $warning\n";
				if($warning =~ m/.*no contact email.*/) {
					$unkemail = 1;
				}
			}
		}
		my $gsmOrganism = $gsmref->{$g}->{'gsmSampleOrganism'};
		$gsmOrganism =~ s/\s+/_/g;
		my $sampleSrcId = "$sourceIdBase$g-$gsmOrganism";
		$gsm .= $sampleSrcId.",";

		print PAS "$gse\t$g\t$sampleSrcId\n";

		$samples{$g} = $sampleSrcId; # store GSM source-id
		my $molecule = $gsmref->{$g}->{'gsmMolecule'};
		if(!defined($molecule)) {
			$molecule = "UNKNOWN";
			print LOG "$g:$g: GEO Parser could not figure out the molecule type\n";
		}
		my $type = "microarray";                                       #$gsmref->{$g}->{''};
		my $dataSource = "GEO";                                        #$gsmref->{$g}->{''};
		my $externalSourceDate = $gsmref->{$g}->{'gsmSubmissionDate'};
		my $originalLog2Median = ".";                                  #$gsmref->{$g}->{''};
		my $person = "";
		my $pref = $gsmref->{$g}->{'contactPeople'};
		foreach my $email (keys(%{$pref})) {
			my $fn = $pref->{$email}->{'contactFirstName'};
			if(!defined($fn)) {
				$fn = "unknown_fn";
			} else {
				$fn =~ s/^\s+//;
				$fn =~ s/\s+$//;
				if(length($fn) > 0) {
					$fn =~ s/ /_/g;
				} else {
					$fn = "unknown_fn";
				}
			}
			my $ln = $pref->{$email}->{'contactLastName'};
			if(!defined($ln)) {
				$ln = "unknown_ln";
			} else {
                                $ln =~ s/^\s+//;
                                $ln =~ s/\s+$//;
                                if(length($ln) > 0) {
                                        $ln =~ s/ /_/g;
                                } else {
                                        $ln = "unknown_ln";
                                }
                        }
			my $inst = $pref->{$email}->{'contactInstitution'};
			if(!defined($inst)) {
				$inst = "unknown_inst";
			} else {
                                $inst =~ s/^\s+//;
                                $inst =~ s/\s+$//;
                                if(length($inst) > 0) {
                                } else {
                                        $inst = "unknown_inst";
                                }
                        }
			if($unkemail) {
				$email = "email\@unknown";
			}
			# Take care of the redundancy (if any) due to letter-case
			$email = lc($email);
			$fn = lc($fn);
			$ln = lc($ln);
			$inst = lc($inst);
			my $md5 = md5_hex("$fn$ln$email");
			my $personSrcId = "$providerId:$loadId.$ver|$md5";
			$person = $person.$personSrcId.",";
			my $personkey = "$personSrcId\t$email\t$fn\t$ln\t$inst";
			$persons{$personkey} = 1;
		}
		$person =~ s/,$//; # remove last comma from the string
		my $gsmTaxId = $gsmref->{$g}->{'gsmTaxID'};
		my $platformRef = $gsmref->{$g}->{'gsmPlatform'};
		my $gpl = $platformRef->{'gplID'};
		my $platformSrcId;
		my $strainSrcId;
		if($gpl eq 'GPL198' || $gsmTaxId eq '3702') {
			$platformSrcId = $athPlaId;
			$strainSrcId = $athStrId;
		} elsif($gpl eq 'GPL4359' || $gsmTaxId eq '3694') {
			$platformSrcId = $ptrPlaId;
			$strainSrcId = $ptrStrId;
		} else {
			print LOG "Strain ID and/or Platform ID error: $gse, $g, $gsmTaxId, $gpl\n";
		}
		#my $platformSrcId = "$sourceIdBase$gpl";
		#my $strainSrcId = "$providerId:$gsmOrganism-$gsmTaxId.$ver|$gsmOrganism";
		#if(!defined($strain{$strainSrcId})) {
		#	my $sciSpName = $gsmOrganism;
		#	$sciSpName =~ s/_/ /g;
		#	$sth->execute($sciSpName);
		#	my @row = $sth->fetchrow_array;
		#	my $genomeId = $row[0];
		#	if(!defined($genomeId)) {
		#		print LOG "Genome Id fetched from DB failed: $gse | $g | $sciSpName\n";
		#	}
		#	$sth->finish;
		#	$strain{$strainSrcId} = "FALSE\t$gsmOrganism-wildtype\tTRUE\t.\t$genomeId\t.\tTRUE\t$sciSpName wildtype";
		#}
		#if(!defined($platforms{$platformSrcId})) {
		#	my $gplTaxId = $platformRef->{'gplTaxID'};
		#	my $gplTechnology = $platformRef->{'gplTechnology'};
		#	my $gplTitle = $platformRef->{'gplTitle'};
		#	$platforms{$platformSrcId} = "$strainSrcId\t$type\t$gplTechnology\t$gpl\t$gplTitle";
		#}
		my $gsmProtocolDesc = $gsmref->{$g}->{'gsmProtocol'};
		my $protocolSrcId;
		undef $protocolSrcId;
		if(defined($gsmProtocolDesc)) {
			$gsmProtocolDesc =~ s/^\s*//;
			$gsmProtocolDesc =~ s/\s*$//;
			if(length($gsmProtocolDesc) > 0) {
				$protocolSrcId = $protocols{$gsmProtocolDesc};
				if(!defined($protocolSrcId)) {
					$protocolSrcId = "$sourceIdBase$gseId-Protocol_$protCount";
					$protocols{$gsmProtocolDesc} = $protocolSrcId;
					++$protCount;
				}
			} else {
				$protocolSrcId = ".";
			}
		} else {
			$protocolSrcId = ".";
		}
		my $experimentalUnitId = ".";                                  #$gsmref->{$g}->{''};
		my $defaultControlSampleId = ".";                              #$gsmref->{$g}->{''};
		my $averagedFromSamples = ".";                                 #$gsmref->{$g}->{''};
		my $title = $gsmref->{$g}->{'gsmTitle'};
		my $description = $gsmref->{$g}->{'gsmDescription'};
		$description =~ s/\s*$//;
		$description =~ s/^\s*//;
		print SAM "$sampleSrcId\t$title\t$description\t$molecule\t$type\t$g\t$dataSource\t$d\t$externalSourceDate\t$originalLog2Median\t$person\t$strainSrcId\t$platformSrcId\t$protocolSrcId\t$experimentalUnitId\t$defaultControlSampleId\t$averagedFromSamples\n";
	}
	foreach my $p (keys(%protocols)) {
		my $protSrcId = $protocols{$p};
		print PRO "$protSrcId\t.\tno-name\t$p\n"; # where $kk = Protocol Description;
	}
	$gsm =~ s/,$//;
	print SER "$seriesSrcId\t$gseId\t$d\t$gseSubmissionDate\t$gsePubMedID\t$gsm\t$title\t$summary\t$design\n";
	$gsm = ""; # re-initialize it for next series
}

$db1h->disconnect;

print "\nWriting out person.tab and platform.tab ...\n";

# write data to person.tab
foreach my $k (keys(%persons)) {
	print PER "$k\n";
}

# write data to platform.tab
#foreach my $k (keys(%platforms)) {
#	print PLA "$k\t".$platforms{$k}."\n";
#}

# write data to publication.tab
foreach my $k (keys(%publication)) {
	print PUB "$k\t".$publication{$k}."\tunknown\n";
}

# write data to strain.tab
#foreach my $strn (keys(%strain)) {
#	print STR "$strn\t".$strain{$strn}."\n";
#}

# close all open files
close SER;
close SAM;
close PER;
close PRO;
#close PLA;
#close STR;
close PUB;
close ERR;
close WAR;
close LOG;
