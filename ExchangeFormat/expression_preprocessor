use POSIX;
use strict;

my $dir = shift;	
my $ls = `ls $dir`;	
my @ls_array = split(/\s+/,$ls);
my %ls_hash;

foreach my $ls_output (@ls_array)
{
	$ls_hash{$ls_output} = 1;
}
my $error_message = '';
if (!exists($ls_hash{'sample.tab'}))
{
	$error_message .= "A sample.tab file was not found in $dir : This program requires a sample.tab file.\n";
}
if (!exists($ls_hash{'measurement.tab'}))
{ 
        $error_message .= "A measurement.tab file was not found in $dir : This program requires a measurement.tab file.\n";
} 
my $sample_file = $dir . "/sample.tab";
open (IN,$sample_file) or die "Unable to open sample file : $sample_file.\n\n"; 
my @sample_lines = (<IN>); 
close(IN);
chomp(@sample_lines);
for (my $i = 0; $i <  scalar(@sample_lines); $i++)
{
	$sample_lines[$i] =~ s/\r//; 
}	
my %sample_lines_hash;  #key source_id ->values an array ref to the elements on the line
my $sample_header_line = shift(@sample_lines);  #Must contain source-id and originalLog2Medain column headers
my @header_columns = split(/\t/,$sample_header_line);
my $originalLog2MedianColIndex = undef;
my $sampleSourceIdColIndex = undef;
my $header_counter = 0;
foreach my $header_column (@header_columns)
{ 
  $header_column = trim($header_column);
  $originalLog2MedianColIndex = column_header_checker($header_column,'^originalLog2Median$',$originalLog2MedianColIndex,$header_counter);
  $sampleSourceIdColIndex = column_header_checker($header_column,'^source-id$',$sampleSourceIdColIndex,$header_counter);
  $header_counter++;
}
unless (defined($originalLog2MedianColIndex) && defined($sampleSourceIdColIndex))
{
	$error_message .= "The sample.tab file must have a 'source-id' and 'originalLog2Median' column headers.\n";
}
if (($originalLog2MedianColIndex eq "duplicate") || ($sampleSourceIdColIndex eq "duplicate"))
{
	$error_message .= "The sample.tab file has a duplicate column headers for 'source-id' and/or 'originalLog2Median'.\n";
}
if ($error_message ne '') 
{ 
        print $error_message; 
        exit; 
} 

foreach my $sample_line (@sample_lines) 
{ 
        my @sample_elements = split("\t",$sample_line); 
        if ($sample_elements[$sampleSourceIdColIndex] eq '') 
        { 
                $error_message .= "One of the lines in the sample file does not contain a source_id\n"; 
        } 
        elsif (!(($sample_elements[$originalLog2MedianColIndex] =~ /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/) 
	      || ($sample_elements[$originalLog2MedianColIndex] eq "."))) 
        { 
                $error_message .= "The Sample with source-id of ".$sample_elements[$sampleSourceIdColIndex].
			       " does not have a valid originalLog2Median (must be a number or .)\n"; 
        } 
        else #populate data_structure. 
        { 
#               #CUSTOM IS ALWAYS FALSE (will add capability for custom averagings later). 
#               $sample_elements[10] = 'FALSE'; 
                $sample_lines_hash{$sample_elements[$sampleSourceIdColIndex]} = \@sample_elements; 
        } 
} 
#check that Median of Log2Level is Zero 
my $measurement_file = $dir . "/measurement.tab"; 
open (IN,$measurement_file) or die "Unable to open measurement file : $measurement_file.\n\n"; 
my @measurement_lines = (<IN>); 
close(IN); 
chomp(@measurement_lines); 
for (my $i = 0; $i <  scalar(@measurement_lines); $i++) 
{ 
        $measurement_lines[$i] =~ s/\r//; 
} 

my $measurement_header_line = shift(@measurement_lines);  #Must contain value, sample-id, source-id and KB-feature-id column headers 
my @measurement_header_columns = split(/\t/,$measurement_header_line); 
my $kbFeatureIdColIndex = undef; 
my $valueColIndex = undef; 
my $sampleIdColIndex = undef; 
my $measurementSourceIdColIndex = undef;
my $header_counter = 0;
foreach my $header_column (@measurement_header_columns) 
{ 
  $header_column = trim($header_column); 
  $kbFeatureIdColIndex = column_header_checker($header_column,'^KB-feature-id$',$kbFeatureIdColIndex,$header_counter); 
  $valueColIndex = column_header_checker($header_column,'^value$',$valueColIndex,$header_counter); 
  $sampleIdColIndex = column_header_checker($header_column,'^sample-id$',$sampleIdColIndex,$header_counter); 
  $measurementSourceIdColIndex = column_header_checker($header_column,'^source-id$',$measurementSourceIdColIndex,$header_counter); 
  $header_counter++; 
} 
unless (defined($kbFeatureIdColIndex) && defined($valueColIndex)  && defined($sampleIdColIndex)  && defined($measurementSourceIdColIndex)) 
{ 
        $error_message .= "The measurement.tab file must have a 'source-id','KB-feature-id','value' and 'sample-id' column headers.\n"; 
} 
if (($kbFeatureIdColIndex eq "duplicate") || ($valueColIndex eq "duplicate") 
   || ($sampleIdColIndex eq "duplicate") || ($measurementSourceIdColIndex eq "duplicate")) 
{ 
        $error_message .= "The measurement.tab file has a duplicate column headers for 'source-id','KB-feature-id','value' and/or 'sample-id'.\n";
        $error_message .= "'source-id' - $measurementSourceIdColIndex \n 'KB-feature-id' - $kbFeatureIdColIndex \n".
	                  "'value' - $valueColIndex \n 'sample-id' - $sampleIdColIndex .\n";
 
} 
if ($error_message ne '') 
{ 
        print $error_message; 
        exit; 
} 
my %measurement_lines_hash; #key {sample_source_id}->{feature_id}= array ref to the elements of the measurement_line 
foreach my $measurement_line (@measurement_lines) 
{ 
        my $measurement_line_error_message = '';	
        my @measurement_elements = split("\t",$measurement_line); 
        if ($measurement_elements[$measurementSourceIdColIndex] eq '') 
        { 
          $measurement_line_error_message .= "One of the lines in the measurement file does not contain a source_id\n"; 
        } 
        else 
        { 
          if (($measurement_elements[$valueColIndex] eq '') || ($measurement_elements[$valueColIndex] eq '.')) 
          { 
                  $measurement_line_error_message .= "The measurement record with the source-id ". 
		  				  $measurement_elements[$measurementSourceIdColIndex] . " is empty for the value\n"; 
          } 
          if (($measurement_elements[$kbFeatureIdColIndex] eq '') || ($measurement_elements[$kbFeatureIdColIndex] eq '.')) 
          { 
                  $measurement_line_error_message .= "The measurement record with the source-id ". 
		  				  $measurement_elements[$measurementSourceIdColIndex] . " does not have a feature_id\n"; 
          } 
          unless ($measurement_elements[$valueColIndex] =~ /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/) 
          { 
                  $measurement_line_error_message .= "The measurement record with the source-id ". 
		  				  $measurement_elements[$measurementSourceIdColIndex] . 
                  				  " does not have a valid value number (".$measurement_elements[$valueColIndex].")\n"; 
          } 
          if (($measurement_elements[$sampleIdColIndex] eq '') || ($measurement_elements[$sampleIdColIndex] eq '.')) 
          { 
                  $measurement_line_error_message .= "The measurement record with the source-id ". 
		  				  $measurement_elements[$measurementSourceIdColIndex] . 
                  				  " does not have a valid sample-id.\n"; 
          } 
          unless (exists($sample_lines_hash{$measurement_elements[$sampleIdColIndex]})) 
          { 
                  $measurement_line_error_message .= "The measurement record with the source-id ". 
                                                  $measurement_elements[$measurementSourceIdColIndex] .
                                                  " has a sample_id that does not exist in the sample.tab file..\n";
          } 
        } 
        if ($measurement_line_error_message ne '') 
        { 
                $error_message .= $measurement_line_error_message; 
        } 
        else #populate data_structure. 
        { 
                $measurement_elements[$valueColIndex] =~ s/\s//g; 
                $measurement_lines_hash{$measurement_elements[$sampleIdColIndex]}->{$measurement_elements[$kbFeatureIdColIndex]} 
						= \@measurement_elements; 
        } 
} 
 
#print "ERROR MESSAGE:\n".$error_message."\n"; 

#go through each sample and load all log2Levels into an array
#numerical sort the array and see if median is zero (within tolerance) 
#if not within tolerance then determine the median replace it within the sample file
# and change all the log2Levels for that sample by subtracting out the determined median.
my $threshold = .00001;
my $need_new_measurement_file = 0;
foreach my $sample_id (sort(keys(%measurement_lines_hash)))
{
	my @sample_measurements = ();
	foreach my $feature_id (keys(%{$measurement_lines_hash{$sample_id}}))
	{
		push(@sample_measurements,$measurement_lines_hash{$sample_id}->{$feature_id}->[$valueColIndex]);
	}
	my @sorted_measurements = sort {$a <=> $b} @sample_measurements;
	my $num_elements = scalar @sorted_measurements;
	my $median;
	if (($num_elements%2) == 0)
	{
		$median = (($sorted_measurements[(($num_elements-1)/2)]) +
			  ($sorted_measurements[(($num_elements)/2)]))/2
	}
	else #odd elements just take middle one
	{
		$median = $sorted_measurements[floor($num_elements/2)]
	}
	#
if ($sample_id eq 'jkbaumohl@lbl.gov:AD_Shew2012.1|growth_expr_LB360min')
{
print "OLD SAMPLE: $sample_id - MEDIAN: $median - NUM ELEMENTS $num_elements \n";
print join("\n",@sorted_measurements); 
}


	if (abs($median) > $threshold)
	{
		$need_new_measurement_file = 1;
		#set the originalLog2Median in for the sample
		$sample_lines_hash{$sample_id}->[$originalLog2MedianColIndex] = $median;
		#change the log2Levels from the original score minus the new median.
		foreach my $feature_id (keys(%{$measurement_lines_hash{$sample_id}})) 
        	{
			$measurement_lines_hash{$sample_id}->{$feature_id}->[$valueColIndex] = 
				$measurement_lines_hash{$sample_id}->{$feature_id}->[$valueColIndex] - $median;
        	}
	}
}

if ($error_message ne "")
{
	print "THE FOLLOWING ERRORS NEED TO BE ADDRESSED BEFORE THE PREPROCESSOR CAN WORK:\n".$error_message."\n";
	exit;
}

if ($need_new_measurement_file == 1)
{
	#Move original sample.tab and measurement.tab to original_sample.tab and original_measurement.tab respectively. 
	#(Only does log2level if the median of all sample was not zero) 
	`mv $dir/sample.tab $dir/original_sample.tab`; 

	`mv $dir/measurement.tab $dir/original_measurement.tab`;
	open (MEASUREMENT_FILE, ">".$measurement_file) or die "Unable to make the measurement file : $measurement_file $!\n";
	print MEASUREMENT_FILE  $measurement_header_line . "\n";
	foreach my $sample_id (sort(keys(%measurement_lines_hash)))
	{
        	foreach my $feature_id (keys(%{$measurement_lines_hash{$sample_id}}))
		{
			my @temp_arr =  @{$measurement_lines_hash{$sample_id}->{$feature_id}};
			print MEASUREMENT_FILE join("\t",@temp_arr) . "\n";
		} 
	}
	close (MEASUREMENT_FILE);

	#make new sample.tab file
	open (SAMPLE_FILE, ">".$sample_file) or die "Unable to make the new sample file : $sample_file $!\n";
	print SAMPLE_FILE $sample_header_line;

	foreach my $sample_source_id (sort(keys(%sample_lines_hash)))
	{
		for (my $i=0;$i<=15 ; $i++)
		{
			print SAMPLE_FILE $sample_lines_hash{$sample_source_id}->[$i] . "\t";
		}
		print SAMPLE_FILE ".\n";
	}

	#close Sample
	close(SAMPLE_FILE);

	print "\nSuccess:\n";
	print "The original $sample_file has been renamed to $dir/original_sample.tab \n";
	print "The original $measurement_file has been renamed to $dir/original_measurement.tab \n"; 

	print "The following_files have been created : \n" .$sample_file . "\n";
	if ($need_new_measurement_file == 1)
	{ 
  	  print $measurement_file . "\n";
	}
}
else
{
	print "\nAll Samples already had a median log level of 0 already.  Nothing needed to be done. \n";
}	






sub column_header_checker ( $ $ $ $ )
{ 
    my $col_name = shift; 
    my $reg_ex = shift; 
    my $column_exists_flag = shift;
    my $counter = shift;
 
    if ($col_name =~ m/$reg_ex/i) 
    { 
        if (defined($column_exists_flag))
        { 
            return "duplicate";
        } 
        else 
        { 
            return $counter; 
        } 
    } 
    else 
    {		
        return $column_exists_flag; 
    } 
} 

# Perl trim function to remove whitespace from the start and end of the string
sub trim($)
{
	my $string = shift;
	$string =~ s/^\s+//;
	$string =~ s/\s+$//;
	return $string;
}
# Left trim function to remove leading whitespace
sub ltrim($)
{
	my $string = shift;
	$string =~ s/^\s+//;
	return $string;
}
# Right trim function to remove trailing whitespace
sub rtrim($)
{
	my $string = shift;
	$string =~ s/\s+$//;
	return $string;
}