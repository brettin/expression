use POSIX;
use strict;
use DBI; 

my $deploy_file = "/kb/dev_container/modules/expression/deploy.cfg";
open (DEPLOY,$deploy_file) or die "Unable to open deploy file : $deploy_file.\n\n"; 
my @deploy_lines = (<DEPLOY>);
close(DEPLOY);
chomp(@deploy_lines);
my $db_name = undef;
my $db_host = undef;
my $db_user = undef;
foreach my $deploy_line (@deploy_lines)
{
	if ($deploy_line =~ m/^dbName/)
	{
		my @temp = split('=',$deploy_line);
		$db_name = trim($temp[1]);
	}
	if ($deploy_line =~ m/^dbUser/) 
        { 
                my @temp = split('=',$deploy_line);
                $db_user = trim($temp[1]);
        } 
        if ($deploy_line =~ m/^dbhost/) 
        { 
                my @temp = split('=',$deploy_line);
                $db_host = trim($temp[1]);
        } 
}

my $dbh = DBI->connect('DBI:mysql:'.$db_name.':'.$db_host, $db_user, '', 
                           { RaiseError => 1, ShowErrorStatement => 1 } 
    );

my $dir = shift;	
my $ls = `ls $dir`;	
my @ls_array = split(/\s+/,$ls);
my %ls_hash;

foreach my $ls_output (@ls_array)
{
	$ls_hash{$ls_output} = 1;
}
my $error_message = '';

#SEE IF STRAIN FILE EXISTS, IF SO CHECK TO SEE IF ALL THE GENOMES EXIST IS IN THE CDM
if (exists($ls_hash{'strain.tab'}))
{ 
  my $strain_file = $dir. "/strain.tab";
  open (STRAIN_IN,$strain_file) or die "Unable to open the strain file : $strain_file .\n";
  my @strain_lines = (<STRAIN_IN>);
  close(STRAIN_IN);
  chomp(@strain_lines);
  for (my $i = 0; $i <  scalar(@strain_lines); $i++) 
  {     
  	$strain_lines[$i] =~ s/\r//;
  } 
  my %genome_id_hash;  #key genome_id ->value : array_ref to the lines that genome_id appears on 
  my $strain_header_line = shift(@strain_lines);  #Must contain Genome-id column headers 
  my @strain_header_columns = split(/\t/,$strain_header_line); 
  my $genomeIdColIndex = undef; 
  my $header_counter = 0; 
  foreach my $header_column (@strain_header_columns) 
  { 
    $header_column = trim($header_column); 
    $genomeIdColIndex = column_header_checker($header_column,'^Genome-id$',$genomeIdColIndex,$header_counter); 
    $header_counter++; 
  } 
  unless (defined($genomeIdColIndex)) 
  { 
    $error_message .= "The strain.tab file must have a 'Genome-id' column headers.\n"; 
  } 
  if ($genomeIdColIndex eq "duplicate") 
  {
	$error_message .= "The strain.tab file has a duplicate column headers for 'Genome-id'.\n"; 
  } 
  if ($error_message ne '') 
  { 
        print $error_message; 
        exit; 
  }  
  my $strain_line_counter = 2;
  foreach my $strain_line (@strain_lines) 
  { 
        my @strain_elements = split("\t",$strain_line); 
        if ($strain_elements[$genomeIdColIndex] eq '') 
        { 
                $error_message .= "One of the lines in the sample file does not contain a source_id\n"; 
        } 
        else #populate data_structure. 
        { 
                #populate the %feature_id_hash
                if (exists($genome_id_hash{$strain_elements[$genomeIdColIndex]}))
                { 
                        #if exists add another line number to array
                        push(@{$genome_id_hash{$strain_elements[$genomeIdColIndex]}},$strain_line_counter);
                } 
                else 
                {
                        #did not exist, initialize the feature with the first_line_number it existed.
                        $genome_id_hash{$strain_elements[$genomeIdColIndex]}=[$strain_line_counter];
                }
	}
	$strain_line_counter++;
  }
  #DETERMINE IF ANY OF GENOMES ARE NOT IN THE CDM
  #Do query vs the DB vs all keys in %genome_id_hash
  #If the genome_id_exists delete the key from the hash  delete $HASH{$key};
  #After done with that and go through the remaining elements in the hash and report those Genomes that were not found in the DB.
  #Throw the an error, exit before modifying any of the files.  
  my $find_genomes_q = qq^ select id from kbase_sapling_v1.Genome where id in (^.
       		       join(",", ("?") x scalar(keys(%genome_id_hash))) . ") ";
  my $find_genomes_qh = $dbh->prepare($find_genomes_q) or die "Unable to prepare find_genomes_q : $find_genomes_q : ".$dbh->errstr();
  $find_genomes_qh->execute(keys(%genome_id_hash)) or die "Unable to execute find_genomes_q : $find_genomes_q : ".$find_genomes_qh->errstr();
  while (my ($db_genome_id) = $find_genomes_qh->fetchrow_array())
  {
	delete $genome_id_hash{$db_genome_id};
  }
  if (scalar(keys(%genome_id_hash)) > 0)
  {
	$error_message .= "\nThe following Genome IDs in the strain.tab file do not exist in the CDM.  ".
		       	  "Line number in the strain tab record in '()'.\n";
	foreach my $temp_genome_id (keys(%genome_id_hash))
	{
		$error_message .= "Genome ID : $temp_genome_id (".join (",",@{$genome_id_hash{$temp_genome_id}}).")\n";
	}
	$error_message .= "\n";
  }
}

if (!exists($ls_hash{'sample.tab'}))
{
	$error_message .= "A sample.tab file was not found in $dir : This program requires a sample.tab file.\n";
}
if (!exists($ls_hash{'measurement.tab'}))
{ 
        $error_message .= "A measurement.tab file was not found in $dir : This program requires a measurement.tab file.\n";
} 
my $sample_file = $dir . "/sample.tab";
open (IN,$sample_file) or die "Unable to open sample file : $sample_file.\n\n"; 
my @sample_lines = (<IN>); 
close(IN);
chomp(@sample_lines);
for (my $i = 0; $i <  scalar(@sample_lines); $i++)
{
	$sample_lines[$i] =~ s/\r//; 
}	
my %sample_lines_hash;  #key source_id ->values an array ref to the elements on the line
my $sample_header_line = shift(@sample_lines);  #Must contain source-id and originalLog2Medain column headers
my @header_columns = split(/\t/,$sample_header_line);
my $originalLog2MedianColIndex = undef;
my $sampleSourceIdColIndex = undef;
my $header_counter = 0;
foreach my $header_column (@header_columns)
{ 
  $header_column = trim($header_column);
  $originalLog2MedianColIndex = column_header_checker($header_column,'^originalLog2Median$',$originalLog2MedianColIndex,$header_counter);
  $sampleSourceIdColIndex = column_header_checker($header_column,'^source-id$',$sampleSourceIdColIndex,$header_counter);
  $header_counter++;
}
unless (defined($originalLog2MedianColIndex) && defined($sampleSourceIdColIndex))
{
	$error_message .= "The sample.tab file must have a 'source-id' and 'originalLog2Median' column headers.\n";
}
if (($originalLog2MedianColIndex eq "duplicate") || ($sampleSourceIdColIndex eq "duplicate"))
{
	$error_message .= "The sample.tab file has a duplicate column headers for 'source-id' and/or 'originalLog2Median'.\n";
}
if ($error_message ne '') 
{ 
        print $error_message; 
        exit; 
} 

foreach my $sample_line (@sample_lines) 
{ 
        my @sample_elements = split("\t",$sample_line); 
        if ($sample_elements[$sampleSourceIdColIndex] eq '') 
        { 
                $error_message .= "One of the lines in the sample file does not contain a source_id\n"; 
        } 
        elsif (!(($sample_elements[$originalLog2MedianColIndex] =~ /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/) 
	      || ($sample_elements[$originalLog2MedianColIndex] eq "."))) 
        { 
                $error_message .= "The Sample with source-id of ".$sample_elements[$sampleSourceIdColIndex].
			       " does not have a valid originalLog2Median (must be a number or .)\n"; 
        } 
        else #populate data_structure. 
        { 
#               #CUSTOM IS ALWAYS FALSE (will add capability for custom averagings later). 
#               $sample_elements[10] = 'FALSE'; 
                $sample_lines_hash{$sample_elements[$sampleSourceIdColIndex]} = \@sample_elements; 
        } 
} 
#check that Median of Log2Level is Zero 
my $measurement_file = $dir . "/measurement.tab"; 
open (IN,$measurement_file) or die "Unable to open measurement file : $measurement_file.\n\n"; 
my @measurement_lines = (<IN>); 
close(IN); 
chomp(@measurement_lines); 
for (my $i = 0; $i <  scalar(@measurement_lines); $i++) 
{ 
        $measurement_lines[$i] =~ s/\r//; 
} 

my $measurement_header_line = shift(@measurement_lines);  #Must contain value, sample-id, source-id and KB-feature-id column headers 
my @measurement_header_columns = split(/\t/,$measurement_header_line); 
my $kbFeatureIdColIndex = undef; 
my $valueColIndex = undef; 
my $sampleIdColIndex = undef; 
my $measurementSourceIdColIndex = undef;
my $header_counter = 0;
foreach my $header_column (@measurement_header_columns) 
{ 
  $header_column = trim($header_column); 
  $kbFeatureIdColIndex = column_header_checker($header_column,'^KB-feature-id$',$kbFeatureIdColIndex,$header_counter); 
  $valueColIndex = column_header_checker($header_column,'^value$',$valueColIndex,$header_counter); 
  $sampleIdColIndex = column_header_checker($header_column,'^sample-id$',$sampleIdColIndex,$header_counter); 
  $measurementSourceIdColIndex = column_header_checker($header_column,'^source-id$',$measurementSourceIdColIndex,$header_counter); 
  $header_counter++; 
} 
unless (defined($kbFeatureIdColIndex) && defined($valueColIndex)  && defined($sampleIdColIndex)  && defined($measurementSourceIdColIndex)) 
{ 
        $error_message .= "The measurement.tab file must have a 'source-id','KB-feature-id','value' and 'sample-id' column headers.\n"; 
} 
if (($kbFeatureIdColIndex eq "duplicate") || ($valueColIndex eq "duplicate") 
   || ($sampleIdColIndex eq "duplicate") || ($measurementSourceIdColIndex eq "duplicate")) 
{ 
        $error_message .= "The measurement.tab file has a duplicate column headers for 'source-id','KB-feature-id','value' and/or 'sample-id'.\n";
        $error_message .= "'source-id' - $measurementSourceIdColIndex \n 'KB-feature-id' - $kbFeatureIdColIndex \n".
	                  "'value' - $valueColIndex \n 'sample-id' - $sampleIdColIndex .\n";
 
} 
if ($error_message ne '') 
{ 
        print $error_message; 
        exit; 
} 
my %measurement_lines_hash; #key {sample_source_id}->{feature_id}= array ref to the elements of the measurement_line 
my %feature_id_hash; #key {feature_id} -> value pointer to array of line numbers that contain that feature.
my $measurement_line_counter = 2;
foreach my $measurement_line (@measurement_lines) 
{ 
        my $measurement_line_error_message = '';	
        my @measurement_elements = split("\t",$measurement_line); 
        if ($measurement_elements[$measurementSourceIdColIndex] eq '') 
        { 
          $measurement_line_error_message .= "One of the lines in the measurement file does not contain a source_id\n"; 
        } 
        else 
        { 
          if (($measurement_elements[$valueColIndex] eq '') || ($measurement_elements[$valueColIndex] eq '.')) 
          { 
                  $measurement_line_error_message .= "The measurement record with the source-id ". 
		  				  $measurement_elements[$measurementSourceIdColIndex] . " is empty for the value\n"; 
          } 
          if (($measurement_elements[$kbFeatureIdColIndex] eq '') || ($measurement_elements[$kbFeatureIdColIndex] eq '.')) 
          { 
                  $measurement_line_error_message .= "The measurement record with the source-id ". 
		  				  $measurement_elements[$measurementSourceIdColIndex] . " does not have a feature_id\n"; 
          } 
	  else
	  {
		#populate the %feature_id_hash
		if (exists($feature_id_hash{$measurement_elements[$kbFeatureIdColIndex]}))
		{
			#if exists add another line number to array
			push(@{$feature_id_hash{$measurement_elements[$kbFeatureIdColIndex]}},$measurement_line_counter);	
		}
		else
		{
			#did not exist, initialize the feature with the first_line_number it existed.
			$feature_id_hash{$measurement_elements[$kbFeatureIdColIndex]}=[$measurement_line_counter];
		}
	  }
          unless ($measurement_elements[$valueColIndex] =~ /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/) 
          { 
                  $measurement_line_error_message .= "The measurement record with the source-id ". 
		  				  $measurement_elements[$measurementSourceIdColIndex] . 
                  				  " does not have a valid value number (".$measurement_elements[$valueColIndex].")\n"; 
          } 
          if (($measurement_elements[$sampleIdColIndex] eq '') || ($measurement_elements[$sampleIdColIndex] eq '.')) 
          { 
                  $measurement_line_error_message .= "The measurement record with the source-id ". 
		  				  $measurement_elements[$measurementSourceIdColIndex] . 
                  				  " does not have a valid sample-id.\n"; 
          } 
          unless (exists($sample_lines_hash{$measurement_elements[$sampleIdColIndex]})) 
          { 
                  $measurement_line_error_message .= "The measurement record with the source-id ". 
                                                  $measurement_elements[$measurementSourceIdColIndex] .
                                                  " has a sample_id that does not exist in the sample.tab file..\n";
          } 
        } 
        if ($measurement_line_error_message ne '') 
        { 
                $error_message .= $measurement_line_error_message; 
        } 
        else #populate data_structure. 
        { 
                $measurement_elements[$valueColIndex] =~ s/\s//g; 
                $measurement_lines_hash{$measurement_elements[$sampleIdColIndex]}->{$measurement_elements[$kbFeatureIdColIndex]} 
						= \@measurement_elements; 
        } 
	$measurement_line_counter++;
} 

#DETERMINE IF ANY OF FEATURES ARE NOT IN THE CDM
#Do query vs the DB vs all keys in %feature_id_hash
#If the feature_id_exists delete the key from the hash  delete $HASH{$key};
#After done with that and go through the remaining elements in the hash and report that those Features were not found in the DB.
#Throw the an error, exit beofre modifying any of the files.
my $find_features_q = qq^ select id from kbase_sapling_v1.Feature where id in (^.
                       join(",", ("?") x scalar(keys(%feature_id_hash))) . ") ";
my $find_features_qh = $dbh->prepare($find_features_q) or die "Unable to prepare find_features_q : $find_features_q : ".$dbh->errstr();
$find_features_qh->execute(keys(%feature_id_hash)) or die "Unable to execute find_features_q : $find_features_q : ".
						   $find_features_qh->errstr();
while (my ($db_feature_id) = $find_features_qh->fetchrow_array())
{
        delete $feature_id_hash{$db_feature_id}; 
} 
if (scalar(keys(%feature_id_hash)) > 0) 
{ 
        $error_message .= "\nThe following Feature IDs in the measurement.tab file do not exist in the CDM.  ".
                          "Line number in the measurement tab record in '()'.\n"; 
        foreach my $temp_feature_id (keys(%feature_id_hash))
        { 
                $error_message .= "Feature ID : $temp_feature_id (".join (",",@{$feature_id_hash{$temp_feature_id}}).")\n";
        } 
        $error_message .= "\n";
} 
if ($error_message ne '') 
{ 
        print $error_message;
        exit; 
} 
#print "ERROR MESSAGE:\n".$error_message."\n"; 

#go through each sample and load all log2Levels into an array
#numerical sort the array and see if median is zero (within tolerance) 
#if not within tolerance then determine the median replace it within the sample file
# and change all the log2Levels for that sample by subtracting out the determined median.
my $threshold = .00001;
my $need_new_measurement_file = 0;
foreach my $sample_id (sort(keys(%measurement_lines_hash)))
{
	my @sample_measurements = ();
	foreach my $feature_id (keys(%{$measurement_lines_hash{$sample_id}}))
	{
		push(@sample_measurements,$measurement_lines_hash{$sample_id}->{$feature_id}->[$valueColIndex]);
	}
	my @sorted_measurements = sort {$a <=> $b} @sample_measurements;
	my $num_elements = scalar @sorted_measurements;
	my $median;
	if (($num_elements%2) == 0)
	{
		$median = (($sorted_measurements[(($num_elements-1)/2)]) +
			  ($sorted_measurements[(($num_elements)/2)]))/2
	}
	else #odd elements just take middle one
	{
		$median = $sorted_measurements[floor($num_elements/2)]
	}
	#print "OLD SAMPLE: $sample_id - MEDIAN: $median - NUM ELEMENTS $num_elements \n";
	if (abs($median) > $threshold)
	{
		$need_new_measurement_file = 1;
		#set the originalLog2Median in for the sample
		$sample_lines_hash{$sample_id}->[$originalLog2MedianColIndex] = $median;
		#change the log2Levels from the original score minus the new median.
		foreach my $feature_id (keys(%{$measurement_lines_hash{$sample_id}})) 
        	{
			$measurement_lines_hash{$sample_id}->{$feature_id}->[$valueColIndex] = 
				$measurement_lines_hash{$sample_id}->{$feature_id}->[$valueColIndex] - $median;
        	}
	}
}

if ($error_message ne "")
{
	print "THE FOLLOWING ERRORS NEED TO BE ADDRESSED BEFORE THE PREPROCESSOR CAN WORK:\n".$error_message."\n";
	exit;
}

if ($need_new_measurement_file == 1)
{
	#Move original sample.tab and measurement.tab to original_sample.tab and original_measurement.tab respectively. 
	#(Only does log2level if the median of all sample was not zero) 
	`mv $dir/sample.tab $dir/original_sample.tab`; 

	`mv $dir/measurement.tab $dir/original_measurement.tab`;
	open (MEASUREMENT_FILE, ">".$measurement_file) or die "Unable to make the measurement file : $measurement_file $!\n";
	print MEASUREMENT_FILE  $measurement_header_line . "\n";
	foreach my $sample_id (sort(keys(%measurement_lines_hash)))
	{
        	foreach my $feature_id (keys(%{$measurement_lines_hash{$sample_id}}))
		{
			my @temp_arr =  @{$measurement_lines_hash{$sample_id}->{$feature_id}};
			print MEASUREMENT_FILE join("\t",@temp_arr) . "\n";
		} 
	}
	close (MEASUREMENT_FILE);

	#make new sample.tab file
	open (SAMPLE_FILE, ">".$sample_file) or die "Unable to make the new sample file : $sample_file $!\n";
	print SAMPLE_FILE $sample_header_line . "\n";

	foreach my $sample_source_id (sort(keys(%sample_lines_hash)))
	{
		for (my $i=0;$i<=15 ; $i++)
		{
			print SAMPLE_FILE $sample_lines_hash{$sample_source_id}->[$i] . "\t";
		}
		print SAMPLE_FILE ".\n";
	}

	#close Sample
	close(SAMPLE_FILE);

	print "\nSuccess:\n";
	print "The original $sample_file has been renamed to $dir/original_sample.tab \n";
	print "The original $measurement_file has been renamed to $dir/original_measurement.tab \n"; 

	print "The following_files have been created : \n" .$sample_file . "\n";
	if ($need_new_measurement_file == 1)
	{ 
  	  print $measurement_file . "\n";
	}
}
else
{
	print "\nAll Samples already had a median log level of 0 already.  Nothing needed to be done. \n";
}	






sub column_header_checker ( $ $ $ $ )
{ 
    my $col_name = shift; 
    my $reg_ex = shift; 
    my $column_exists_flag = shift;
    my $counter = shift;
 
    if ($col_name =~ m/$reg_ex/i) 
    { 
        if (defined($column_exists_flag))
        { 
            return "duplicate";
        } 
        else 
        { 
            return $counter; 
        } 
    } 
    else 
    {		
        return $column_exists_flag; 
    } 
} 

# Perl trim function to remove whitespace from the start and end of the string
sub trim($)
{
	my $string = shift;
	$string =~ s/^\s+//;
	$string =~ s/\s+$//;
	return $string;
}
# Left trim function to remove leading whitespace
sub ltrim($)
{
	my $string = shift;
	$string =~ s/^\s+//;
	return $string;
}
# Right trim function to remove trailing whitespace
sub rtrim($)
{
	my $string = shift;
	$string =~ s/\s+$//;
	return $string;
}